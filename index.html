<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homage to the Square</title>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #f5f5f5;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #container {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease;
            outline: none;
            user-select: none;
        }
        
        #info {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #333;
            font-size: 16px;
            font-weight: 300;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            line-height: 1.4;
            transition: opacity 0.3s ease;
        }
        
        #container:hover #info, #container:focus-visible #info {
            opacity: 0.8;
        }
        
        #squares-container {
            position: relative;
            width: 500px;
            height: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .square {
            position: absolute;
            transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center center;
            will-change: width, height, left, top, background-color, filter;
        }
        
        .square:nth-child(1) { z-index: 1; }
        .square:nth-child(2) { z-index: 2; }
        .square:nth-child(3) { z-index: 3; }
        .square:nth-child(4) { z-index: 4; }

        #export-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            z-index: 20;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 300;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        
        #container:hover #export-btn, #container:focus-visible #export-btn {
            opacity: 1;
            pointer-events: auto;
        }
        
        #export-btn:hover {
            background: #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        #color-info {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: #666;
            font-size: 12px;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            font-weight: 300;
            text-align: right;
            transition: opacity 0.3s ease;
        }
        
        #container:hover #color-info, #container:focus-visible #color-info {
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="container" tabindex="0" aria-label="Homage to the Square interactive container">
        <div id="info">
            <strong>Homage to the Square</strong><br>
            After Josef Albers<br>
            <small>Click or press Space/Enter to explore color relationships</small>
        </div>
        
        <div id="squares-container">
            <div class="square" id="square1"></div>
            <div class="square" id="square2"></div>
            <div class="square" id="square3"></div>
            <div class="square" id="square4"></div>
        </div>
        
        <div id="color-info">
            <span id="palette-name">Warm Earth</span><br>
            <small>Colors interact through simultaneous contrast</small>
        </div>
        
        <button id="export-btn" tabindex="0" aria-label="Export as PNG">Export PNG</button>
    </div>
    
    <canvas id="export-canvas" style="display:none;"></canvas>
    
    <script>
        // Helper for HSL->HEX (needed for random palettes)
        function hslToHex(h, s, l) {
            s /= 100;
            l /= 100;
            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c/2, r=0, g=0, b=0;
            if (0 <= h && h < 60) { r = c; g = x; b = 0; }
            else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
            else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
            else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
            else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
            else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            return "#" + [r, g, b].map(x => x.toString(16).padStart(2, "0")).join("");
        }

        // --- Color palettes and random generation (as before, omitted for brevity) ---
        // ... (colorPalettes, generateRandomPalette, generateAnalogous, etc.) ...
        // For brevity, keep your original colorPalettes and random palette logic here.

        // Expanded Josef Albers-inspired color palettes with extensive variations
        const colorPalettes = [
            // Warm Earth Tones (Extended)
            { name: "Warm Earth", colors: ["#8B4513", "#CD853F", "#F4A460", "#FFF8DC"] },
            { name: "Desert Sand", colors: ["#704214", "#B8860B", "#DAA520", "#FFFACD"] },
            { name: "Clay Pottery", colors: ["#A0522D", "#D2691E", "#F4A460", "#FFEFD5"] },
            { name: "Rust Canyon", colors: ["#B22222", "#CD853F", "#F4A460", "#FFFAF0"] },
            { name: "Amber Glow", colors: ["#8B4513", "#DAA520", "#FFD700", "#FFFACD"] },
            { name: "Sandstone", colors: ["#8B7355", "#D2B48C", "#F5DEB3", "#FFFEF7"] },
            { name: "Burnt Umber", colors: ["#8A2BE2", "#CD853F", "#DEB887", "#FFF8DC"] },
            { name: "Sienna Earth", colors: ["#A0522D", "#CD853F", "#F4A460", "#FFEFD5"] },
            { name: "Terracotta", colors: ["#8B4513", "#CD853F", "#DEB887", "#F5DEB3"] },
            { name: "Adobe Clay", colors: ["#CD853F", "#DEB887", "#F5DEB3", "#FFFEF7"] },
            // ... (rest of palettes unchanged, omitted for brevity)
            // Orange & Red Spectrum, Golden Yellows, Cool Blues, etc.
            // (same as your original file)
            { name: "Neon", colors: ["#10b981", "#06b6d4", "#f472b6", "#fbbf24"] }
        ];

        function generateRandomPalette() {
            const algorithms = [
                generateAnalogous,
                generateComplementary,
                generateTriadic,
                generateMonochromatic,
                generateSplitComplementary,
                generateTetradic
            ];
            const algorithm = algorithms[Math.floor(Math.random() * algorithms.length)];
            return algorithm();
        }

        function generateAnalogous() {
            const baseHue = Math.random() * 360;
            const colors = [];
            for (let i = 0; i < 4; i++) {
                const hue = (baseHue + i * 30) % 360;
                const sat = 60 + Math.random() * 30;
                const light = 25 + i * 18 + Math.random() * 10;
                colors.push(hslToHex(hue, sat, light));
            }
            return { name: "Analogous Harmony", colors };
        }
        function generateComplementary() {
            const hue1 = Math.random() * 360;
            const hue2 = (hue1 + 180) % 360;
            const colors = [];
            for (let i = 0; i < 2; i++) {
                const sat = 50 + Math.random() * 40;
                const light = 30 + i * 25 + Math.random() * 15;
                colors.push(hslToHex(hue1, sat, light));
            }
            for (let i = 0; i < 2; i++) {
                const sat = 50 + Math.random() * 40;
                const light = 30 + i * 25 + Math.random() * 15;
                colors.push(hslToHex(hue2, sat, light));
            }
            return { name: "Complementary", colors };
        }
        function generateTriadic() {
            const baseHue = Math.random() * 360;
            const colors = [];
            const hues = [baseHue, (baseHue + 120) % 360, (baseHue + 240) % 360];
            colors.push(hslToHex(hues[0], 70, 25));
            colors.push(hslToHex(hues[1], 65, 45));
            colors.push(hslToHex(hues[2], 60, 65));
            colors.push(hslToHex(hues[0], 40, 85));
            return { name: "Triadic", colors };
        }
        function generateMonochromatic() {
            const hue = Math.random() * 360;
            const colors = [];
            const saturations = [80, 70, 50, 30];
            const lightnesses = [20, 40, 60, 80];
            for (let i = 0; i < 4; i++) {
                colors.push(hslToHex(hue, saturations[i], lightnesses[i]));
            }
            return { name: "Monochromatic", colors };
        }
        function generateSplitComplementary() {
            const baseHue = Math.random() * 360;
            const colors = [];
            const hues = [baseHue, (baseHue + 150) % 360, (baseHue + 210) % 360];
            colors.push(hslToHex(hues[0], 70, 25));
            colors.push(hslToHex(hues[1], 65, 45));
            colors.push(hslToHex(hues[2], 60, 65));
            colors.push(hslToHex(hues[0], 40, 85));
            return { name: "Split-Complementary", colors };
        }
        function generateTetradic() {
            const baseHue = Math.random() * 360;
            const colors = [];
            const hues = [
                baseHue,
                (baseHue + 90) % 360,
                (baseHue + 180) % 360,
                (baseHue + 270) % 360
            ];
            for (let i = 0; i < 4; i++) {
                const sat = 60 + Math.random() * 20;
                const light = 30 + i * 15 + Math.random() * 10;
                colors.push(hslToHex(hues[i], sat, light));
            }
            return { name: "Tetradic", colors };
        }

        let currentPaletteIndex = 0;
        let frame = 0;
        let isAnimating = true;

        const container = document.getElementById('container');
        const squaresContainer = document.getElementById('squares-container');
        const squares = [
            document.getElementById('square1'),
            document.getElementById('square2'),
            document.getElementById('square3'),
            document.getElementById('square4')
        ];
        const paletteNameElement = document.getElementById('palette-name');
        const exportBtn = document.getElementById('export-btn');
        const exportCanvas = document.getElementById('export-canvas');

        // Albers-style square sizing (following his proportional relationships)
        const squareSizes = [450, 340, 230, 120]; // Outer to inner
        const squareOffsets = [
            { x: 0, y: 0 },      // Outer square centered
            { x: 0, y: 25 },     // Second square slightly down (Albers often offset)
            { x: 0, y: 35 },     // Third square more down
            { x: 0, y: 45 }      // Inner square most down
        ];

        function updateSquares() {
            const palette = colorPalettes[currentPaletteIndex];
            paletteNameElement.textContent = palette.name;
            
            // Subtle animation parameters
            const time = frame * 0.008;
            
            squares.forEach((square, index) => {
                const size = squareSizes[index];
                const offset = squareOffsets[index];
                
                // Very subtle breathing effect
                const breathe = Math.sin(time + index * 0.5) * 0.02 + 1;
                const currentSize = size * breathe;
                
                // Subtle position shifts (maintaining Albers' offset philosophy)
                const xShift = Math.sin(time * 0.7 + index) * 2;
                const yShift = Math.cos(time * 0.5 + index) * 1.5;
                
                square.style.width = `${currentSize}px`;
                square.style.height = `${currentSize}px`;
                square.style.backgroundColor = palette.colors[index];
                square.style.left = `${(500 - currentSize) / 2 + offset.x + xShift}px`;
                square.style.top = `${(500 - currentSize) / 2 + offset.y + yShift}px`;
                
                // Very subtle color shifts to demonstrate simultaneous contrast
                const hueShift = Math.sin(time * 0.3 + index * 0.8) * 5;
                const brightness = Math.sin(time * 0.4 + index * 0.6) * 0.05 + 1;
                
                square.style.filter = `hue-rotate(${hueShift}deg) brightness(${brightness})`;
            });
        }

        function nextPalette() {
            // 50% chance to generate a completely random palette using color theory
            if (Math.random() < 0.5) {
                colorPalettes.push(generateRandomPalette());
                currentPaletteIndex = colorPalettes.length - 1;
                // Remove old random palettes to prevent memory buildup
                if (colorPalettes.length > 120) {
                    colorPalettes.splice(90, 1); // Remove from random section
                    currentPaletteIndex--;
                }
            } else {
                currentPaletteIndex = (currentPaletteIndex + 1) % Math.min(colorPalettes.length, 90); // Cycle through predefined palettes
            }
            
            // Visual feedback
            container.style.transform = 'scale(0.98)';
            setTimeout(() => {
                container.style.transform = 'scale(1)';
            }, 150);
            
            updateSquares();
        }

        function animate() {
            if (isAnimating) {
                frame++;
                updateSquares();
            }
            requestAnimationFrame(animate);
        }

        function exportCurrentComposition() {
            const canvas = exportCanvas;
            const ctx = canvas.getContext('2d');
            const size = 800; // High resolution export
            
            canvas.width = size;
            canvas.height = size;
            
            // Background
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, size, size);
            
            const palette = colorPalettes[currentPaletteIndex];
            const scale = size / 500; // Scale factor for export
            
            // Draw squares from outer to inner
            for (let index = 0; index < 4; index++) {
                const squareSize = squareSizes[index] * scale;
                const offset = squareOffsets[index];
                const x = (size - squareSize) / 2 + offset.x * scale;
                const y = (size - squareSize) / 2 + offset.y * scale;
                ctx.fillStyle = palette.colors[index];
                ctx.fillRect(x, y, squareSize, squareSize);
            }
            // Download
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `albers-homage-${palette.name.toLowerCase().replace(/\s+/g, '-')}.png`;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- Improved click handling for reliability ---
        function handleContainerClick(e) {
            // Only fire for clicks that are not from the export button or its descendants
            if (!exportBtn.contains(e.target)) {
                nextPalette();
            }
        }

        container.addEventListener('click', handleContainerClick);

        exportBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            exportCurrentComposition();
        });

        // Keyboard support (focus container for accessibility)
        container.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'Enter') {
                e.preventDefault();
                nextPalette();
            }
            if (e.code === 'KeyP') {
                e.preventDefault();
                isAnimating = !isAnimating;
            }
        });

        // Accessibility: allow focus on container for keyboard events
        container.addEventListener('focus', () => {
            container.classList.add('focus-visible');
        });
        container.addEventListener('blur', () => {
            container.classList.remove('focus-visible');
        });

        // Touch optimization: tap to change palette on mobile
        container.addEventListener('touchstart', (e) => {
            if (!exportBtn.contains(e.target)) {
                nextPalette();
            }
        });

        // Initialize
        updateSquares();
        animate();

        // Autofocus for keyboard
        window.addEventListener('DOMContentLoaded', () => {
            container.focus();
        });
    </script>
</body>
</html>